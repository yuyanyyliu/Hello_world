## 面向对象的特征之二：继承性

#### 继承性的好处（why）

- 减少了代码的冗余，提高了代码的复用性
- 便于功能的扩展
- 为之后的多态性的使用，提供了前提

#### 继承性的格式：class A extends B{ }

​	A:子类，派生类，subclass

​	B:父类，超类，基类，superclass

​	一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的的结构，属性，方法

- 特殊的父类中声明为private的属性或方法，子类继承父类后，仍然认为获取了父类中私有结构，只是因为封装性的影响，使得子类不能直接调用父类的结构而已。

- 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的拓展

#### Java中关于继承性的规定

一个类可以被多个子类继承

Java中类的单继承性：一个类只能有一个父类

子父类是相对的概念

子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类

子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法

#### 补充

- 如果没有显示的声明一个父类，则此类继承于java.lang.Object类

- 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类

- 意味着，所有的java类具有java.lang.Object类声明的功能

  

## 方法的重写

**定义:**

在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置，覆盖。在程序执行时，子类的方法将覆盖父类的方法

**要求：**

- 子类重写的方法必须和父类被重写的方法具有相同的方法名称，参数列表

- 子类重写的方法返回值类型不能大于父类被重写的方法的返回值类型

- 子类重写的方法使用的方法权限不能小于父类被重写的方法的发那个问权限

  ​	子类不能重写父类中声明为Private权限的方法

- 子类方法抛出异常不能大于父类被重写方法的异常

**重写的规定**：

​	方法的声明： 权限修饰符 返回值类型 方法名（形参列表）throws 异常的类型{

​									//方法体

​							}

​	约定俗成：子类中的叫重写的方法，父类中的叫被重写的方法

- ​	子类重写的方法名和形参列表与父被重写的方法的方法名和形参列表相同

- ​	子类重写的权限修饰符不小于父类被重写的方法的权限修饰符

​		特殊：子类中不能重写父类中声明为private的方法

- ​	返回值类型：
  - 父类被重写的返回值类型是void,则子类重写的方法的返回值类型只能是void
  - 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
  - 父类被重写的方法的返回值类型是基本数据类型（double），则子类重写的方法的返回值类型必须是相同的基本数据类型（double）

- ​     子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型

子类和父类中的同名参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）

### 关键字：super

super关键字的使用

1. super理解为：父类的

2. super可以用来调用：属性，方法，构造器

3. super的使用：

   > 可以在子类的方法或构造器中。使用"super.属性"或"super.方法"的方式，显示的调用父类中声明的属性或方法。但是，通常情况下，习惯省略"super"

   > 特殊情况：当子类和父类中定义了同名的属性时，我们想要在子类中调用父类中声明的属性，则必须显示的使用"super.属性"的方式，表明调用的是父类中声明的属性。

   > 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显示的使用"super.方法"的方式，表明调用的是父类中被重写的方法

4. super调用构造器

- 我们可以在子类的的构造器中显示的使用”super(形参列表)"的方式，调用父类中声明的制定的构造器
- "super(形参列表)"的使用，必须声明在子类构造器的首行
- 在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
- 在构造器的首行，没有显示的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参
- 在类的多个构造器中，至少有一个类的构造器使用了"super(形参列表)"，调用父类中的构造器

### 子类对象实例化过程

从结果上看：(继承性)

子类继承父类以后，就获取了父类中声明的属性或方法

创建子类的对象，在堆空间中，就会加载所有父类中声明的属性

从过程上看：

当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用

明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。